---
title: "VHL snRNAseq QC report"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
output:
  html_document:
    keep_md: true
    code_folding: show
    toc: true
    toc_float: true
    toc_collapsed: true
    toc_depth: 4
    number_sections: true
    theme: lumen
---

```{r load_vhl_package, include = F}
library(devtools)
load_all()
```

`r if (testing == T) {"# Test run! {-}" }`

```{r testing, include = testing == T, eval = testing == T}
args <- list(
  parse_dir = paste0(get_base_dir(), "parse_pipeline/"),
  experiment = "221202_A01366_0326_AHHTTWDMXY",
  genome = "hg38",
  sublibrary = "SHE5052A9_S101",
  parse_analysis_subdir = "all-well/DGE_filtered/",
  remove_doublets = T,
  do_filtering = T,
  min_nuclei_per_gene = 5,
  min_nCount_RNA = 300,
  max_nCount_RNA = 10000,
  min_nFeature_RNA = 200,
  max_nFeature_RNA = 10000,
  max_percent_mito = 15,
  vars_to_regress = c("percent_mito", "nCount_RNA"),
  n_dims = NULL,
  final_clustering_resolution = 0.3,
  do_integration = F,
  sample_subset = c("N090_V124A", "N090_V127"),
  final_annotations = NULL,
  testing = T,
  rerun = F
)
out <- list(
  base = "out/test/",
  cache = "out/test/cache/"
)
```

```{r initialise, include = F}
# load args to global env
list2env(args, globalenv())

# set seed for repeatability
set.seed(42)
random_seed = 42

# gridExtra, clustree, monocle3 must be loaded in the environment (due to package-specific bugs)
library(clustree)
library(gridExtra)
library(monocle3)

# set ggplot theme
ggplot2::theme_set(ggplot2::theme_bw())
ggplot2::theme_update(legend.text = ggplot2::element_text(size = 7))

# chunk setup
knitr::opts_chunk$set(fig.align = "center",
                      cache.path = out$cache,
                      dpi = 300)
```

# Run info {-}

```{r args, echo = F}
knitr::kable(tibble::tibble(argument = names(args), value = args %>% purrr::map(paste, collapse = ", ") %>% unlist))
```

# Output info {-}

Output files will be saved to **`r out$base`**.

Figures will be saved to **`r out$base`qc_report_files/figure-html/**.

Intermediate objects will be cached to **`r out$cache`**.

# `Seurat` pre-processing

## Load data and apply gene-level filter

Load Parse Biosciences split-pipe pipeline output as a Seurat object with no cut-offs, remove any missing samples, add sample metadata, add summary statistics, and optionally subset samples. Then filter nuclei per gene. 
Gene-level filtering is performed at this point, based on the `min_nuclei_per_gene` argument. Genes that are present in very few nuclei of the dataset (e.g., <3) are uninformative and unlikely to help in differentiating between groups of nuclei. In general, most genes removed by this filtering step will be those not detected in any nuclei, which will help to trim the size of the object. Additionally, genes are removed that have entries in all nuclei but whose entries are all zero. 

The minimum number of nuclei per gene is set to **`r min_nuclei_per_gene`**.

``` {r load_data, warning = F}
seu <- xfun::cache_rds({
  load_parse_to_seurat(
    parse_dir,
    experiment,
    genome,
    sublibrary,
    parse_analysis_subdir,
    min_nFeature_RNA = 0,
    min_nuclei_per_gene = min_nuclei_per_gene,
    sample_subset = sample_subset,
    remove_na_samples = T,
    do_add_sample_metadata = T,
    do_add_summary_stats = T,
    groupings,
    statistics
  )
}, file = "seu.rds", rerun = rerun)
```

```{r nuclei_per_sample_plot, class.source = 'fold-hide', message = F, warning = F, fig.cap = "Plot of nuclei per sample"}
p <-
  dplyr::tibble(sample_id = names(table(seu$sample)),
                n_nuclei = table(seu$sample)) %>%
  ggplot2::ggplot(ggplot2::aes(x = sample_id, y = n_nuclei)) +
  ggplot2::geom_col() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
p
```

```{r summary_statistics_plot, class.source = 'fold-hide', message = F, warning = F, fig.height = 15, fig.cap = "Plot of summary statistics by sample"}
p <-
  seu@misc$summary_stats %>%
  ggplot2::ggplot(ggplot2::aes(x = sample, y = value)) +
  ggplot2::geom_col() +
  ggplot2::facet_grid(statistic ~ ., scales = "free") +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
p
```

- `median_tscp_per_cell` - Median number of transcripts detected per cell.
- `median_genes_per_cell` - Median number of genes detected per cell.
- `fraction_tscp_in_cells` - Number of unique transcripts associated with barcodes labeled as "cells" divided by the number of reads associated with barcodes labeled as "background" in the barcode-rank plot.
- `cell_tscp_cutoff` -  Minimum number of transcripts required for barcode to be considered a "cell". Moreover, all barcodes containing "x" number transcripts and greater will be considered a cell, and anything less will be considered background. 
- `valid_barcode_fraction` - Fraction of starting (fastq) reads that contain a valid set of barcodes. Barcodes are corrected together (as a triple), allowing for multiple differences from the ideal sequences (Mismatches and/or InDels up to edit distance 2 are considered for each barcode).

## Filter nuclei

Nucleus-level filtering is performed, applying cut-offs to `nCount_RNA`, `nFeature_RNA`, `percent_mito`, and `doublet` values of each nucleus.

* Unusually high transcript / gene counts indicate multiplets.
* Unusually low transcript / gene counts indicate barcoding of nuclei with damaged membranes, which are likely low-quality and uninformative.
* A high percentage of mitochondrial genes indicates death, loss of cytoplasmic RNA, or increased apoptosis. Differences in the application of this filter between scRNA-seq and snRNA-seq are not well covered in literature. Intuitively, snRNA-seq data should be treated with a more stringent cut-off, as it should only include nuclear RNA. However, the renal cortex has an exceptionally high level of mitochondrial activity, so this cut-off has been relaxed somewhat for the VHL dataset. 
* Nuclei with a high nFeature_RNA:nCount_RNA ratio could be from dying cells.

### Cell counts

From [**Parse Biosciences Computational Support**](https://support.parsebiosciences.com/hc/en-us/articles/4483706086164-How-are-cell-counts-determined-)

> *Cell counts are estimated by ordering barcodes by their respective transcript counts and plotting them along a gradient with log transformed axes. This plot is commonly referred to as a "barcode-rank" plot. When there is a significant change in the number of transcripts associated with each barcode (i.e. the large "drop" in the curve), a minimum transcript threshold is established as the steepest point in the curve. Every barcode greater than or equal to this threshold is labeled as a "cell", while every barcode below this threshold is labeled as "background". Only barcodes that meet the minimum transcript threshold are included in the resulting summary report and filtered expression matrix (i.e. the DGE_filtered folder in the pipeline output directory).*
> 
> *There may be situations where the cell count estimate does not line up with the researcher's expectations, or the barcode-rank plot lacks a distinct "drop" in the curve. The latter situation can occur when there is an excess number of dead/damaged cells in the data set, creating an intermediate "smoothness" on the curve where a drop would be expected. In order to manually adjust the cell cutoff there are two options: rerun the pipeline at --mode dge using one of the cell calling parameters described in the article Pipeline Options, or read in the unfiltered (DGE_unfiltered) matrix into an analysis package such as Seurat or Scanpy and adjust the minimum transcript threshold in the cell quality control steps. If the user plans on performing a more granular analysis in package such as Seurat or Scanpy, the latter option may be preferable.*

```{r barcode_rank, echo = F}
# knitr::include_graphics(paste(parse_dir, "analysis", experiment, genome, sublibrary, "all-well/figures/fig_tscp_cell_cutoff.png", sep = "/"))
```

### Annotate doublets

Putative doublets are identified using the `scDblFinder` package. This package creates artificial doublets by grouping together random pairs of nuclei within each sample to create pseudo-doublets, and then identifying nuclei that cluster near to these pseudo-doublets during dimensionality reduction. This co-clustering indicates that they carry a doublet signature. 

The `remove_doublets` argument is set to **`r remove_doublets`**.
`r if (remove_doublets == T) {"Doublets will be identified and removed." }`
`r if (remove_doublets == F) {"A dummy column will be introduced, treating all nuclei as though they are singlets."}`

```{r identify_doublets, eval = remove_doublets == T, include = remove_doublets == T}
seu <- xfun::cache_rds({
  annotate_doublets(seu)
}, file = "seu_doublets.rds", rerun = rerun)
```

```{r ignore_doublets, eval = remove_doublets == F, include = remove_doublets == F}
seu$doublet <- 0
```

```{r detected_doublets, eval = remove_doublets == T, class.source = 'fold-hide', fig.cap = "Plot of detected doublets in each sample (using scDblFinder)"}
p_dat <- 
  seu@meta.data[,c("sample", "doublet", "nCount_RNA", "nFeature_RNA")] %>% 
  dplyr::group_by(sample) %>%
  dplyr::mutate(is_doublet = doublet == 1,
                n_doublets = sum(doublet),
                n_singlets = sum(!doublet))
p <- 
  p_dat %>% 
  tidyr::pivot_longer(c("n_doublets", "n_singlets"), values_to = "count") %>%
  ggplot2::ggplot(ggplot2::aes(y = count, x = sample, fill = name)) +
  ggplot2::geom_col() +
  ggplot2::scale_fill_manual(
    name = "",
    values = c(n_singlets = dittoSeq::dittoColors()[1],
               n_doublets = dittoSeq::dittoColors()[2])) +
  ggplot2::theme(axis.text = ggplot2::element_text(size = 6),
                 axis.text.x = ggplot2::element_text(angle = 90),
                 legend.position = "none") +
  p_dat %>%
  tidyr::pivot_longer(c("nCount_RNA", "nFeature_RNA"), values_to = "count") %>%
  ggplot2::ggplot(ggplot2::aes(y = count, x = sample)) +
  ggplot2::geom_jitter(data = . %>% dplyr::filter(!is_doublet), height = 0,
                       ggplot2::aes(colour = "singlet"), size = 0.2) +
  ggplot2::geom_jitter(data = . %>% dplyr::filter(is_doublet), height = 0,
                       ggplot2::aes(colour = "doublet"), size = 0.2) +
  ggplot2::facet_wrap(~ name, scales = "free") +
  ggplot2::scale_colour_manual(
    name = "",
    values = c(singlet = dittoSeq::dittoColors()[1],
               doublet = dittoSeq::dittoColors()[2])) +
  ggplot2::theme(axis.text = ggplot2::element_text(size = 7),
                 axis.text.x = ggplot2::element_text(angle = 90),
                 axis.title.y = ggplot2::element_blank(),
                 legend.position = "bottom") +
  patchwork::plot_layout(ncol = 2, widths = c(1, 2))
p
```

### Annotate transcript types

Proportions of transcript types of interest (mitochondrial, ribosomal, globin) are annotated. Mitochondrial genes are particularly of interest for filtering, but it is good practice to inspect the others as well.

* `percent_mito` - A high percentage of mitochondrial genes indicates death, loss of cytoplasmic RNA, or increased apoptosis.
* `percent_ribo` - mRNA that code for ribosomal proteins. They do not point to specific issues, but it can be good to have a look at their relative abundance. They can have biological relevance.
* `percent_globin` - Globin genes are very abundant in erythrocytes. Depending on your application, you can expect ‘contamination’ of erythrocytes and select against it.

```{r annotate_transcript_types}
seu <- annotate_proportions_of_transcript_types(seu)
```

### Define nucleus-level filters

The `do_filtering` argument is set to **`r do_filtering`**.
`r if (do_filtering == T) {"Filters will be applied." }`
`r if (do_filtering == F) {"Dummy filters will be set (min = -Inf, max = Inf) and all nuclei will be retained." }`

```{r get_filters}
seu <- get_filters(
  seu,
  do_filtering,
  remove_doublets,
  min_nCount_RNA,
  max_nCount_RNA,
  min_nFeature_RNA,
  max_nFeature_RNA,
  max_percent_mito
)
```

#### Fail criteria statistics

```{r calc_n_retained, include = F}
n_retained <- nrow(dplyr::filter(seu@misc$nucleus_filtering, pass))
n_total <- nrow(seu@misc$nucleus_filtering)
```

`r paste0("**", round((n_retained / n_total) * 100, 1), "%** (", n_retained, " / ", n_total, ") of nuclei retained.")`

```{r fail_criteria_stats, echo = F, message = F}
options(knitr.kable.NA = '')
dplyr::left_join(
  seu@misc$filters %>% dplyr::bind_rows(.id = "fail_criteria") %>%
    tidyr::pivot_longer(c("min", "max")) %>%
    dplyr::transmute(fail_criteria = paste(name, fail_criteria, sep = "_"), value),
  seu@misc$nucleus_filtering %>%
  dplyr::filter(!pass) %>%
  tidyr::separate_longer_delim(fail_criteria, ",") %>%
  dplyr::count(fail_criteria) %>%
  dplyr::mutate(`%` = round((n / n_total) * 100, 2)),
  by = "fail_criteria"
) %>%
  dplyr::arrange(-n) %>%
  dplyr::bind_rows(dplyr::tibble(fail_criteria = "total:", 
                                 n = n_total - n_retained,
                                 `%` = round((n / n_total) * 100, 2))) %>%
  knitr::kable(align = c("c", "c", "c", "c", "c"))
```

```{r fail_criteria_plot, class.source = 'fold-hide', fig.cap = "Plot of the proportions of filtered nuclei and their fail criteria for each sample"}
p <- 
  seu@misc$nucleus_filtering %>%
  dplyr::group_by(sample) %>%
  dplyr::count(fail_criteria) %>%
  ggplot2::ggplot(ggplot2::aes(x = sample, y = n, fill = fail_criteria)) +
  ggplot2::geom_col() +
  ditto_colours +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
p
```

```{r filters_vs_distribution_vln_plot, class.source = 'fold-hide', message = F, warning = F, fig.height = 10, fig.width = 10, fig.cap = "Plot of filters vs feature distribution"}
p <- 
    seu@misc$nucleus_filtering %>%
    tidyr::pivot_longer(names(seu@misc$filters)) %>%
    dplyr::left_join(seu@misc$filters %>%
                       purrr::map(~dplyr::as_tibble(.)) %>%
                       dplyr::bind_rows(.id = "name"),
                     by = "name") %>%
    dplyr::group_by(fail_criteria) %>%
    ggplot2::ggplot(ggplot2::aes(x = sample, y = value)) +
    ggplot2::geom_jitter(ggplot2::aes(colour = pass),
                         height = 0, alpha = 0.5, size = 0.6) +
    ggplot2::geom_violin(ggplot2::aes(fill = sample), alpha = 0.8,
                         draw_quantiles = 0.5) +
    ggplot2::geom_hline(ggplot2::aes(yintercept = min), colour = "red") +
    ggplot2::geom_hline(ggplot2::aes(yintercept = max), colour = "red") +
    ggplot2::facet_wrap(~ name, scales = "free") +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90)) +
    ditto_colours +
    ggplot2::scale_colour_manual(values = c("darkgrey", "black"))
p
```

```{r log_filters_vs_distribution_vln_plot, class.source = 'fold-hide', message = F, warning = F, fig.height = 10, fig.width = 10, fig.cap = "Plot of filters vs feature distribution (log scale)"}
p + ggplot2::scale_y_log10()
```

```{r nucleus_scatter_with_filters_plot, class.source = 'fold-hide', fig.width = 10, fig.cap = "Plot of filters against distribution of nuclei"}
p <- 
    plot_nucleus_scatter_with_filters(seu, "nCount_RNA", "percent_mito", ditto_colours) +
    ggplot2::theme(legend.position = "none") +
    plot_nucleus_scatter_with_filters(seu, "nCount_RNA", "nFeature_RNA", ditto_colours)
p
```

```{r log_nucleus_scatter_with_filters_plot, class.source = 'fold-hide', fig.width = 10, fig.cap = "Plot of filters against distribution of nuclei (log scale)"}
p + ggplot2::scale_x_log10() + ggplot2::scale_y_log10()
```

### `r if (do_filtering) {"Apply nucleus-level filters"}`

```{r filter_nuclei, eval = do_filtering == T, include = do_filtering == T}
seu_filtered <- xfun::cache_rds({
  # remove failing nuclei 
  seu <- subset(seu, cells = unique(dplyr::filter(seu@misc$nucleus_filtering, pass)$nucleus))
  # remove genes with no counts
  counts <- as.matrix(seu@assays$RNA@counts)
  seu <- subset(seu, features = rownames(counts[rowSums(counts) > 0, ]))
  seu
}, file = "seu_filtered.rds", rerun = rerun)
seu <- seu_filtered
```

# `Seurat` processing

## Find highest variable genes

Find the most highly variable genes (HVGs) across samples.

```{r hvg, message = F, warning = F}
seu <- xfun::cache_rds({
  Seurat::FindVariableFeatures(seu)
}, file = "seu_hvg.rds", rerun = rerun)
```

```{r hvg_scatter_plot, class.source = 'fold-hide', warning = F, message = F, fig.cap = "Plot of HVGs"}
p <- 
  Seurat::LabelPoints(
    plot = Seurat::VariableFeaturePlot(seu, raster = F),
    points = head(Seurat::VariableFeatures(seu), 10),
    repel = T
  ) +
    ggplot2::theme(legend.position = "top")
p
```

```{r hvg_heatmap_plot, class.source = 'fold-hide', fig.cap = "Heatmap of top 20 HVGs"}
p <- 
  dittoSeq::dittoHeatmap(
    seu,
    genes = head(Seurat::VariableFeatures(seu), 20),
    annot.by = "sample",
    scaled.to.max = T
  )
p
```

## Integration (optional)

The `do_integration` argument is set to **`r do_integration`**.
Samples will `r if (do_integration == F) {"**not**"}` be integrated.

`r if (do_integration) {"The Seurat object is first split into samples. Normalisation and identification of variable features is then undertaken in each sample independently. Integration anchors are found and the samples are re-integrated after correcting for sample-level effects and then scaled."}`

```{r integrate, eval = F, include = F}
# 1) split samples
seu_split <- seu %>%
  Seurat::SplitObject(split.by = integration_col)

# 2) normalise and find variable features within each sample
seu_split <- seu_split %>%
  purrr::map(function(samp) {
    samp %>%
      Seurat::NormalizeData() %>%
      Seurat::FindVariableFeatures()
  })

# 3) find integration anchors
int_anchors <- seu_split %>%
  Seurat::FindIntegrationAnchors(anchor.features = Seurat::SelectIntegrationFeatures(seu_split))

# 4) integrate, set "integrated" as default assay
seu <- Seurat::IntegrateData(anchorset = int_anchors)
Seurat::DefaultAssay(seu) <- "integrated"

# 5) post-integration scaling
seu <- Seurat::ScaleData(seu)

# save seu_integrated
saveRDS(seu, paste0(out$base, "/seu_integrated.rds"))
```

## Normalisation and scaling

`Seurat::SCTransform()` performs normalisation and scaling of the data. 

Variables to regress out of the `SCTransform` residuals  (set by argument `vars_to_regress`) are **`r paste(vars_to_regress, collapse = "** and **")`**. These variables are prevented from contributing much to the PCA during dimensionality reduction, and thus confounding the analysis, as they are considered to be a source of irrelevant variation.

```{r sctransform, eval = do_integration == F, include = do_integration == F, results = F, warning = F}
seu <- xfun::cache_rds({
  Seurat::SCTransform(seu, vars.to.regress = vars_to_regress)
}, file = "seu_transformed.rds", rerun = rerun)
```

## Annotate cell cycle phases

Nuclei are assigned a score representing the likelihood that they are in each phase of the cell cycle. This is based on the expression levels of genes associated with each phase. The highest probability phase of each nucleus is stored in a new "Phase" column of the metadata.

```{r annotate_cell_cycle_phases}
seu <- Seurat::CellCycleScoring(
  seu,
  s.features = Seurat::cc.genes$s.genes,
  g2m.features = Seurat::cc.genes$g2m.genes
)
```

## Defining dimensionality

Dimensionality reduction is performed to isolate the strongest signals and to remove background noise. First, we must perform linear dimensionality reduction and then decide the dimensionality of the data.

### Linear dimensionality reduction (PCA)

```{r run_pca}
seu <- xfun::cache_rds({
  Seurat::RunPCA(seu)
}, file = "seu_pca.rds", rerun = rerun)
```

```{r pc1_vs_pc2_plot, class.source = 'fold-hide', fig.cap = "Plot of PC1 vs PC2, coloured by sample"}
p <- 
  dittoSeq::dittoDimPlot(seu, "sample", reduction.use = "pca", raster = F) 
p
```

```{r pca_dim, class.source = 'fold-hide', fig.cap = "Plot of cells and genes sorted by their PC scores for PC1 and PC2"}
p <- 
  Seurat::DimHeatmap(
    seu,
    dims = 1:2,
    cells = 500,
    balanced = TRUE,
    raster = F,
    fast = F
  )
p
```

```{r top_genes_pc1_pc2, class.source = 'fold-hide', fig.cap = "Plot of top genes associated with PC1 and PC2"}
p <- 
  Seurat::VizDimLoadings(seu, dims = 1:2, reduction = "pca")
p
```

### Dimensionality of the data

The dimensionality of the dataset to use for downstream analysis must be decided. This is the number of principal components believed to capture the majority of true biological signal in the dataset. Using too many PCs usually does not affect the result too much, while including too few PCs can be detrimental, as meaningful biological variation may be lost. Therefore, it is better to be overgenerous when defining the dimensionality of the data than to underestimate it.

The dimensionality can be decided by consulting the elbow plot (see below) and manually picking a value (set by argument `n_dims`) or it can be calculated using the `intrinsicDimension` package. 

```{r usr_n_dims_msg, echo = F, eval = !is.null(n_dims), results = 'asis'}
cat("### Manually\n")
cat(paste0("Dimensionality of the data is **", n_dims, "** (set by argument n_dims).\n"))
```

```{r usr_n_dims, include = !is.null(n_dims), eval = !is.null(n_dims)}
final_n_dims <- n_dims
```

#### intrinsicDimension

```{r iD_msg, echo = F, eval = is.null(n_dims), results = 'asis'}
cat("No value was provided for `n_dims`, so dimensionality will be calculated using the intrinsicDimensions package.\n")
```

The dimensionality of the dataset can be estimated using the `intrinsicDimension` package. This bypasses the manual approach of reading the elbow plot, but can sometimes be a bit too conservative. Therefore, if `n_dims` is not defined by the user, the dimensionality is set as double the `intrinsicDimension` estimate. 

```{r iD_n_dims}
n_dims_iD <- xfun::cache_rds({
  intrinsicDimension::maxLikGlobalDimEst(
    seu@reductions$pca@cell.embeddings,
    k = 10
  )$dim.est %>% round(0)
}, file = "n_dims_iD.rds", rerun = rerun)
generous_n_dims <- round(2 * n_dims_iD, 0)
```

```{r iD_n_dims_set, include = is.null(n_dims), eval = is.null(n_dims)}
final_n_dims <- generous_n_dims
```

Dimensionality set to **`r final_n_dims`**.

```{r elbow_plot, class.source = 'fold-hide', fig.cap = "Elbow plot"}
p <-
  Seurat::ElbowPlot(seu, ndims = max(50, final_n_dims)) &
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = final_n_dims, 
                 colour = ifelse(is.null(n_dims), "chosen n_dims", "user-provided n_dims")),
                 linewidth = 1) &
  ggplot2::geom_vline(ggplot2::aes(xintercept = n_dims_iD, colour = "intrisicDimensions"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::geom_vline(ggplot2::aes(xintercept = generous_n_dims, colour = "generous (iD x 2)"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::scale_colour_manual(
    name = "n_dims cut-off",
    values = c(`chosen n_dims` = dittoSeq::dittoColors()[[1]],
               `user-provided n_dims` = dittoSeq::dittoColors()[[1]],
               intrisicDimensions = dittoSeq::dittoColors()[[2]],
               `generous (iD x 2)` = dittoSeq::dittoColors()[[3]])) &
  ggplot2::theme(legend.position = c(0.7, 0.9),
                 legend.background = ggplot2::element_rect(fill = "white"))
p
```

# `Monocle3` processing

The `Monocle3` package provides alternative processing approaches for single cell data.   

First, we must convert the data to Monocle3's proprietary `cell_data_set` object and fill in gene names and cell cycle scores.

```{r seu_to_cds, results = F, warning = F}
cds <- xfun::cache_rds({
  cds <- SeuratWrappers::as.cell_data_set(seu_filtered, assay = "RNA")
  SummarizedExperiment::rowData(cds)$gene_short_name <- 
    row.names(SummarizedExperiment::rowData(cds))
  SummarizedExperiment::colData(cds)$Phase <- 
    seu$Phase
  cds
}, file = "cds.rds", rerun = rerun)
```

## Re-pre-processing and linear dimensionality reduction

First, we perform normalisation and principal component analysis again. We use the previously decided dimensionality of the data (**`r final_n_dims`**) from the `Seurat` section.

```{r preprocessing}
cds <- xfun::cache_rds({
  monocle3::preprocess_cds(cds, num_dim = final_n_dims)
}, file = "cds_lin_dim_red.rds", rerun = rerun)
```

## Non-linear dimensionality reduction 

Next, we perform non-linear dimensionality reduction of the data (UMAP). 

```{r nonlin_dim_redu, results = F, warning = F, message = F}
cds <- xfun::cache_rds({
  monocle3::reduce_dimension(cds, preprocess_method = "PCA")
}, file = "cds_nonlin_dim_red.rds", rerun = rerun)
```

Plotting all different groupings of the data onto the reductions can help reveal batch effects. If certain experimental variables seem to strongly influence the grouping of cells, these effects can be removed. If so, use the `align_cds` step from [this tutorial](https://cole-trapnell-lab.github.io/monocle3/docs/clustering/#reduce-dimension).

```{r avail_groupings, include = F}
# amend groupings
avail_groupings <- groupings[groupings %in% colnames(SummarizedExperiment::colData(cds))]
```

```{r groupings_vs_reductions, class.source = 'fold-hide', fig.dim = c(10, 35), fig.cap = "Plot of all Monocle3 dimensionality reductions, coloured by groupings"}
# fig.dim = get_fig_dims(length(avail_groupings) * (length(cds@reduce_dim_aux) + 1), n_cols = length(cds@reduce_dim_aux) + 1), 
# plot all groupings vs all reductions
redus <- c("PCA", "UMAP")
groupings_vs_reductions <- list()
purrr::walk(avail_groupings, function(grouping) {
  purrr::walk(redus, function(redu) {
    title <- paste0(redu, "_vs_", grouping)
    p <- 
      monocle3::plot_cells(
        cds, 
        reduction_method = redu, 
        color_cells_by = grouping,
        show_trajectory_graph = F, 
        label_cell_groups = F)
    groupings_vs_reductions[[paste0(grouping, "_legend")]] <<-
      lemon::g_legend(p)
    groupings_vs_reductions[[title]] <<- 
      p + ggplot2::theme(legend.position = "none")
  })
})
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = groupings_vs_reductions,
    nrow = length(avail_groupings),
    ncol = length(redus) + 1,
    layout_matrix = matrix(
      1:length(groupings_vs_reductions),
      length(avail_groupings),
      length(redus) + 1,
      TRUE
    ),
    top = NULL
  )
p
```

## Clustering

From [**Clarke et al., 2021**](https://www.nature.com/articles/s41596-021-00534-0)

>  ***Annotating cell states and gradients***
>
>  *When analyzing and characterizing novel cell types, it is important to determine whether they represent a stable cell type or contain multiple cell states. The definitions of cell type and state are not yet standardized, but a stable cell type may be expected to have homogeneous gene expression across a cluster and be compact in a 2D projection plot, whereas cell gradients appear as a spread-out string of cells and cell states (e.g., cell cycle state). Expression gradients indicate continuous differences that are present in the cell population, which could represent states like the cell cycle, immune activation63, spatial patterning64 or transient developmental stages. Care must be taken to distinguish biologically meaningful cell states and experimental batch effects, which can manifest in a similar way.*

We perform unsupervised transcriptome similarity-based clustering to identify groups of nuclei with relatively homogeneous transcript profiles (united by a shared celltype / state). Clustering is performed at different resolutions to explore how groupings change across the parameter space. The aim is to find a resolution at which the clusters appear to best reflect true biological subpopulations of the dataset. 

This process is based on the assumption that true discrete clusters of nuclei do exist within the dataset. The preceding nucleus filtering, feature selection, and dimensionality reduction steps were taken to distill only the highest quality features that reflect the underlying structure of the population and to remove noise that distracts from this structure.  

As with the final dimensionality parameter, there is no deterministic way to set the final clustering resolution and no definitive best value. Instead, one must qualitatively assess clustering outputs for the given dataset and pick a 'good' resolution. Typically, a 'good' final resolution is taken as one that groups nuclei into celltypes. However, looking at multiple clustering resolutions of the same dataset can provide multiple true and valuable conclusions about the dataset at multiple levels of functional subspecialisation of cells. 

Setting a **low clustering resolution** will produce fewer clusters, reflect the broadest subdivisions between groups of nuclei (e.g. different tissues / differentiation lineages), and is more robust to noise, but can miss important local structure within the dataset. 

**Higher clustering resolutions** will result in more, increasingly granular clusters and can reveal celltype-level groups. In can also reveal new / rare celltypes that are hidden at lower resolutions. Setting the clustering resolution too high, however, can produce meaningless groups and lead to overfitting. 

`Monocle3` offers an unsupervised clustering function. This function also separates cells into superclusters, called partitions. These represent higher order communities within the dataset, allowing the different resolutions to coexist for downstream analysis.

From **`Monocle3::cluster_cells` vignette**

> *Unsupervised clustering of cells is a common step in many single-cell expression workflows. In an experiment containing a mixture of cell types, each cluster might correspond to a different cell type. This function takes a cell_data_set as input, clusters the cells using Louvain/Leiden community detection, and returns a cell_data_set with internally stored cluster assignments. In addition to clusters this function calculates partitions, which represent superclusters of the Louvain/Leiden communities that are found using a kNN pruning method.*

From [**Monocle3 documentation**](https://cole-trapnell-lab.github.io/monocle3/docs/trajectories/)

> *Although cells may continuously transition from one state to the next with no discrete boundary between them, Monocle does not assume that all cells in the dataset descend from a common transcriptional "ancestor". In many experiments, there might in fact be multiple distinct trajectories. For example, in a tissue responding to an infection, tissue resident immune cells and stromal cells will have very different initial transcriptomes, and will respond to infection quite differently, so they should be a part of the same trajectory.*
>
> *Monocle is able to learn when cells should be placed in the same trajectory as opposed to separate trajectories through its clustering procedure. Recall that we run cluster_cells(), each cell is assigned not only to a cluster but also to a partition. When you are learning trajectories, each partition will eventually become a separate trajectory. *

We can now cluster the cells. Monocle3 does not require a user-defined clustering resolution, as it can detect an optimum resolution automatically. Additionally, it groups the data into both high-resolution clusters and low-resolution superclusters (a.k.a. partitions) simultaneously.

```{r cluster_cells}
lvls <- c("cluster", "partition")
cds <- xfun::cache_rds({
  cds <- monocle3::cluster_cells(cds, random_seed = random_seed)
  # add it to the colData
  SummarizedExperiment::colData(cds)$cluster <- monocle3::clusters(cds)
  SummarizedExperiment::colData(cds)$partition <- monocle3::partitions(cds)
  cds
}, file = "cds_clustered.rds", rerun = rerun) 
```

`Monocle3` has estimated the optimum clustering resolution for the dataset to be **`r optim_res`**.

```{r clustering_tree, class.source = 'fold-hide', fig.dim = c(10, 5), fig.cap = "Clustering tree from partitions (grouping 1) to clusters (grouping 2) of cells"}
library(clustree)
p <-
  data.frame("grouping1" = monocle3::partitions(cds),
             "grouping2" = monocle3::clusters(cds)) %>%
    clustree::clustree(prefix = "grouping")
p
```

```{r clusters_and_partitions, class.source = 'fold-hide', fig.dim = c(10, 5), fig.cap = "Plot of Monocle3 UMAP, coloured by cluster and by partition"}
final_umap <- 
  lvls %>%
  purrr::map(function(lvl) {
    dittoSeq::dittoDimPlot(cds, lvl, size = 0.5, xlab = NULL, ylab = NULL) +
    ggplot2::geom_label(
      data = SummarizedExperiment::colData(cds) %>%
        dplyr::as_tibble() %>%
        dplyr::right_join(get_centroids(cds, "UMAP", lvl), by = lvl) %>%
        dplyr::distinct(get(lvl), x, y),
      ggplot2::aes(x, y, label = `get(lvl)`),
      size = 3, fill = "white", alpha = 0.7, label.size = NA) +
    umap_void_theme
  }) 
names(final_umap) <- lvls
p <- 
  final_umap[["cluster"]] + final_umap[["partition"]]
p
```

## Differential expression analysis

Once cells have been clustered, we can isolate genes that are highly differentially expressed between the clusters. These cluster marker genes can indicate active programmes 

First, we identify the top genes that are most specifically expressed in each cluster and each partition. 

```{r cluster_markers, eval = T, results = F, warning = F, message = F}
# monocle3::top_markers has a bug, so this function doesn't work:
# marker_test_res <- monocle3::top_markers(cds, group_cells_by = "cluster", reference_cells = 1000)

# using a debugged version of the function ()
cds_markers <- xfun::cache_rds({
  cds_markers <- 
    lvls %>%
    purrr::map(function(lvl) {
      top_markers_develop(cds, group_cells_by = lvl)
    }) %>%
    setNames(lvls)
  cds_markers
}, file = "cds_markers.rds", rerun = rerun)

# get top 3 markers per cluster/partition
top_cds_markers <- 
  cds_markers %>%
  purrr::map(function(lvl) {
    lvl %>%
      dplyr::as_tibble() %>%
      dplyr::filter(fraction_expressing >= 0.10) %>%
      dplyr::group_by(cell_group) %>%
      dplyr::arrange(desc(as.numeric(cell_group))) %>%
      dplyr::top_n(3, pseudo_R2)
  })
```

```{r top_markers, eval = T, class.source = 'fold-hide', fig.dim = c(10, dplyr::n_distinct(monocle3::clusters(cds))), fig.cap = "Plot of the mean expression across cells and percentage of cells in each group that express the top 3 marker genes of each group"}
# monocle3::plot_genes_by_group has a bug, so this function doesn't work:
# p <-
#   monocle3::plot_genes_by_group(
#     cds,
#     markers = top_specific_marker_ids,
#     ordering_type = "maximal_on_diag",
#     max.size=3) +
#     ggplot2::theme(text = ggplot2::element_text(size = 8))

# using dittoSeq::dittoDotPlot instead
p <- 
  lvls %>%
  purrr::map(function(lvl) {
    dittoSeq::dittoDotPlot(
      cds, 
      vars = top_cds_markers[[lvl]] %>% dplyr::pull(gene_id) %>% unique(),
      group.by = lvl,
      x.labels.rotate = F) +
    ggplot2::coord_flip() +
    ggplot2::theme(text = ggplot2::element_text(size = 8))
  }) %>%
  gridExtra::marrangeGrob(nrow = 1, ncol = 2, top = NULL)
p
```

## Celltype annotation

The conventional approach to celltype annotation for sc/snRNAseq datasets is to inspect known marker genes from each of the celltypes that are expected and likely to be found at the sample site. Known relationships between marker genes and celltypes of interest can be obtained from databases or manually curated from literature. Then, the expression profiles of all markers from all celltypes across all clusters is programmatically or visually inspected and clusters are labelled according to their marker profile. 

### Automated celltype annotation using database markers

The package `SingleR` returns "the best annotation for each cell in a test dataset, given a labelled reference dataset in the same feature space". Using the human primary cell atlas from `celldex`, we can find the nearest reference celltype to each nucleus in the dataset. This approach is good because it is unbiased and does not require manual assignment, but it is unclear how well snRNAseq output will map onto a scRNAseq atlas. Additionally, the reference dataset from `celldex` is more rigid, cannot be customised to the use case, and does not contain transformed celltypes.

Some annotations will contain very few nuclei. These are usually not of interest and clutter up plotting, so we remove annotations assigned to < 10 nuclei.

```{r singler_annots, message = F, warning = F}
cds_singler <- xfun::cache_rds({
  singler_refs <- celldex::BlueprintEncodeData()
  cds_singler <- SingleR::SingleR(
    test = cds@assays@data$counts,
    ref = singler_refs,
    labels = colnames(singler_refs))
  cds_singler
}, file = "cds_singler.rds", rerun = rerun)
cds <- xfun::cache_rds({
  # add singler annotation
  SummarizedExperiment::colData(cds) <- 
    SummarizedExperiment::colData(cds) %>%
    cbind(
      cds_singler %>%
    dplyr::as_tibble() %>%
    dplyr::select(singler_annot_fine = labels) %>%
    dplyr::group_by(singler_annot_fine) %>%
    dplyr::left_join(
      SummarizedExperiment::colData(singler_refs) %>%
        tibble::as_tibble(rownames = "singler_annot_fine") %>%
        dplyr::select(singler_annot_fine, singler_annot_main = label.main))
    )
  # add main/fine labels for partitions/clusters
  for (lvl in c("cluster", "partition")) {
    for (annot in c("singler_annot_fine", "singler_annot_main")) {
      SummarizedExperiment::colData(cds)[, paste(lvl, annot, sep = "_")] <-
        get_singler_annot_label(cds, annot, lvl)
    }
  }
  # return
  cds
}, file = "cds_singler_annotated.rds", rerun = rerun)
```

```{r singler_annot_fine_heatmap, class.source = 'fold-hide', fig.width = 10, fig.cap = "Heatmap of fine celltype annotation scores from SingleR"}
annotation_col <- 
  SummarizedExperiment::colData(cds)[, c("cluster", "partition", "singler_annot_main")] %>% 
  as.data.frame()
if (dplyr::n_distinct(SummarizedExperiment::colData(cds)$nih_pid, na.rm = T) > 1) {
  annotation_col$nih_pid <- SummarizedExperiment::colData(cds)$nih_pid
}
if (dplyr::n_distinct(SummarizedExperiment::colData(cds)$lesion_type, na.rm = T) > 1) {
  annotation_col$lesion_type <- SummarizedExperiment::colData(cds)$lesion_type
}
cds_singler$main_labels <- SummarizedExperiment::colData(cds)$singler_annot_main
p <-
  SingleR::plotScoreHeatmap(
    cds_singler, 
    show.labels = F,
    annotation_col = annotation_col,
    fontsize_row = 7)
p
```

```{r umap_vs_singler_annots, class.source = 'fold-hide', results = F, fig.width = 10, fig.height = 8, fig.cap = "Plot of UMAP clusters, coloured by SingleR annotation and labelled by the major SingleR annotation(s) per cluster"}
p <- list()
purrr::walk(c("cluster", "partition"), function(lvl) {
  purrr::walk(c("singler_annot_fine", "singler_annot_main"), function(annot) {
    label_col <- paste(lvl, annot, sep = "_")
    p_i <-
      dittoSeq::dittoDimPlot(cds, annot, main = gsub("_", " ", label_col), size = 0.7) +
      ggrepel::geom_label_repel(
        data = 
          dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
          dplyr::select(dplyr::all_of(c(lvl, label_col))) %>%
          dplyr::right_join(get_centroids(cds, "UMAP", lvl), by = lvl) %>%
          dplyr::distinct(),
        ggplot2::aes(x, y, label = get(label_col)),
        min.segment.length = 0,
        size = 1.5, fill = 'white', alpha = 0.8, seed = 1234, label.size = NA
      ) 
    p[[paste0("legend_", annot)]] <<- lemon::g_legend(p_i)
    p[[label_col]] <<- p_i + umap_void_theme 
  })
}) 
design <- "
122443
155663
"
patchwork::wrap_plots(p, design = design)
```

```{r singler_annots_bar, class.source = 'fold-hide', fig.cap = "Plot of SingleR annotation composition of samples"}
p <-
  dittoSeq::dittoBarPlot(
  cds,
  var = "singler_annot_main",
  group.by = "sample",
  scale = "count",
  main = "",
  legend.show = F
  ) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, size = 5),
                 legend.text = ggplot2::element_text(size = 5)) +
  dittoSeq::dittoBarPlot(cds,
                         var = "singler_annot_main",
                         group.by = "cluster",
                         scale = "count",
                         main = "") +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90, size = 5),
                 legend.text = ggplot2::element_text(size = 5)) +
  patchwork::plot_layout(
    ncol = 2,
    widths = c(
      SummarizedExperiment::colData(cds)$sample %>% dplyr::n_distinct(),
      SummarizedExperiment::colData(cds)$cluster %>% dplyr::n_distinct()
    )
  )
p
```

```{r singler_annots_alluvial, class.source = 'fold-hide', fig.width = 10, fig.cap = "Alluvial plot of assignment paths of nuclei from samples to clusters to partitions to SingleR annotations, coloured by cluster"}
p <-
  dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
  dplyr::group_by(sample, partition, cluster, singler_annot_main) %>%
  dplyr::count() %>%
  dplyr::ungroup() %>%
  ggforce::gather_set_data(1:4) %>%
  dplyr::mutate(x = dplyr::case_when(x == 1 ~ "sample",
                                     x == 2 ~ "partition",
                                     x == 3 ~ "cluster",
                                     x == 4 ~ "singler_annot_main") %>%
                  factor(levels = c("sample", "partition", "cluster", 
                                    "singler_annot_main"))) %>%
  ggplot2::ggplot(ggplot2::aes(
                    x = x,
                    id = id,
                    split = y,
                    value = n
                  )) +
  ggforce::geom_parallel_sets(ggplot2::aes(fill = cluster),
                              axis.width = 0.15,
                              alpha = 0.75) +
  ggforce::geom_parallel_sets_axes(fill = "lightgrey",
                                   axis.width = 0.15) +
  ggforce::geom_parallel_sets_labels(angle = 0, 
                                     nudge_x = c(
                                       rep(-0.3, dplyr::n_distinct(SummarizedExperiment::colData(cds)$sample)),
                                       rep(0, dplyr::n_distinct(SummarizedExperiment::colData(cds)$partition)),
                                       rep(0, dplyr::n_distinct(SummarizedExperiment::colData(cds)$cluster)),
                                       rep(0.4, dplyr::n_distinct(SummarizedExperiment::colData(cds)$singler_annot_main))
                                     )) +
  ggplot2::theme_void() +
  ggplot2::theme(legend.position = "none",
                 axis.text.x = ggplot2::element_text(face = "bold", size = 15)) +
  ditto_colours
p
```

### Manual celltype annotation using curated literature markers

```{r cds_avail_markers, echo = F}
avail_markers <- get_available_markers(cds, markers)
```

Literature markers for celltypes of interest in VHL ccRCC tumours were gathered from previous sc/snRNAseq studies of sporadic ccRCC. 

```{r all_modules_heatmap, echo = F, warning = F, message = F, fig.dim = c(10, 20), fig.cap = "Heatmap of all module scores for all Monocle3 clusters"}
df <- 
  avail_markers %>%
  purrr::map(purrr::map, purrr::map, dplyr::as_tibble) %>% 
  purrr::map(purrr::map, dplyr::bind_rows, .id = "module") %>%
  purrr::map(dplyr::bind_rows, .id = "source") %>%
  dplyr::bind_rows(.id = "study") %>%
  dplyr::distinct() %>%
  dplyr::mutate(unique_module = paste(study, substr(source, 1, 3), module) %>% janitor::make_clean_names(allow_dupes = T)) %>%
  dplyr::group_by(unique_module) %>%
  dplyr::mutate(module_size = dplyr::n_distinct(value),
                module = paste0("(", module_size, ") ", module)) %>%
  dplyr::ungroup()

# genes, grouped into modules
gene_group_df <- 
  df %>% 
  dplyr::select(value, unique_module) 

# cells, grouped into clusters and partitions
cell_group_df <- 
  tibble::tibble(
    cell = row.names(SummarizedExperiment::colData(cds)), 
    cluster = monocle3::clusters(cds),
    partition = monocle3::partitions(cds))

# row annotations (study, source)
row_annotations <-
  df %>% 
  dplyr::distinct(unique_module, module, source, study) %>%
  tibble::column_to_rownames("unique_module")

# col annotations (cluster, partition)
col_annotations <-
  cell_group_df %>%
  dplyr::distinct(cluster, partition) %>%
  tibble::column_to_rownames("cluster")

# get row and col annotation colours
colours <- 
  list(source = row_annotations$source,
       study = row_annotations$study,
       partition = col_annotations$partition) %>%
  purrr::map(function(i) {
    dittoSeq::dittoColors()[1:length(unique(i))] %>%
      setNames(unique(i))
    }
  )

# check if >1 partition
multiple_partitions <- dplyr::n_distinct(cell_group_df$partition) > 1
```

#### Study-specific modules vs clusters

```{r modules_vs_clusters_heatmap, echo = F, warning = F, message = F, fig.dim = c(10, 20), fig.cap = "Heatmap of all module scores for all Monocle3 clusters"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df %>% dplyr::filter(!grepl("consensus", unique_module)), 
    cell_group_df[, c("cell", "cluster")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     labels_row = row_annotations[rownames(agg_mat), ]$module,
                     annotation_row = row_annotations[rownames(agg_mat), c("source", "study")],
                     annotation_col = col_annotations,
                     annotation_colors = colours, border_color = NA,
                     fontsize = 8)
p
```

#### Consensus modules vs clusters

```{r consensus_modules_vs_clusters_heatmap, echo = F, warning = F, message = F, fig.dim = c(10, 15), fig.cap = "Heatmap of all module scores, collapsed to consensus modules, for all Monocle3 clusters"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df %>% dplyr::filter(grepl("consensus", unique_module)), 
    cell_group_df[, c("cell", "cluster")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     labels_row = row_annotations[rownames(agg_mat), ]$module,
                     annotation_col = col_annotations,
                     annotation_colors = colours, border_color = NA,
                     fontsize = 8)
p
```

#### Consensus modules vs partitions

```{r consensus_modules_vs_partitions_heatmap, eval = multiple_partitions == T, echo = F, warning = F, message = F, fig.dim = c(10, 15), fig.cap = "Heatmap of all module scores, collapsed to consensus modules, for all Monocle3 partitions"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df %>% dplyr::filter(grepl("consensus", unique_module)), 
    cell_group_df[, c("cell", "partition")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     labels_row = row_annotations[rownames(agg_mat), ]$module,
                     annotation_colors = colours, border_color = NA,
                     fontsize = 8)
p
```

#### Balzer modules vs clusters

```{r balzer_modules_vs_clusters_heatmap, echo = F, warning = F, message = F, fig.dim = c(10, 15), fig.cap = "Heatmap of Balzer module scores for all Monocle3 clusters"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df %>% dplyr::filter(grepl("balzer", unique_module)), 
    cell_group_df[, c("cell", "cluster")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     labels_row = row_annotations[rownames(agg_mat), ]$module,
                     annotation_colors = colours, border_color = NA,
                     fontsize = 8)
p
```

#### Balzer modules vs partitions

```{r balzer_modules_vs_partitions_heatmap, eval = multiple_partitions == T, echo = F, warning = F, message = F, fig.dim = c(10, 15), fig.cap = "Heatmap of Balzer module scores for all Monocle3 partitions"}
agg_mat <- 
  monocle3::aggregate_gene_expression(
    cds, 
    gene_group_df %>% dplyr::filter(grepl("balzer", unique_module)), 
    cell_group_df[, c("cell", "partition")])
p <-
  pheatmap::pheatmap(agg_mat, scale = "row", clustering_method = "ward.D2",
                     labels_row = row_annotations[rownames(agg_mat), ]$module,
                     annotation_colors = colours, border_color = NA,
                     fontsize = 8)
p
```

```{r knit_module_plots, echo = FALSE, warning = F, message = F, results = 'asis'}
# get available markers
consensus_avail_markers <- 
  list(consensus = get_available_markers(cds, markers)$consensus)

to_knit <- c()
agg_mat <- list()
genes <- list()
cell_group_df <- list()

for(study in names(consensus_avail_markers)) {

  to_knit <- c(to_knit, '\n', get_subheading(study))

  for(source in names(consensus_avail_markers[[study]])) {

    to_knit <- c(to_knit, get_subsubheading(study, source, consensus_avail_markers))
    author <- get_author(study)
    chunk_name <- paste(author, substr(source, 1, 3)) %>% janitor::make_clean_names()
  
    for(ct in names(consensus_avail_markers[[study]][[source]])) {
      
      to_knit <- c(to_knit, paste0("\n##### Population: **", ct, "**\n"))
      chunk_name_ct <- paste(chunk_name, ct) %>% janitor::make_clean_names()
      ct_markers <- consensus_avail_markers[[study]][[source]][[ct]]
      n_ct_markers <- length(ct_markers)
      
      for(lvl in lvls) {

        chunk_name_lvl <- paste(chunk_name_ct, lvl) %>% janitor::make_clean_names()
  
        if (dplyr::n_distinct(SummarizedExperiment::colData(cds)[, lvl]) > 1 & 
            n_ct_markers > 1) {
          
          genes[[chunk_name_lvl]] <- consensus_avail_markers[[study]][[source]][[ct]]
          cell_group_df[[chunk_name_lvl]] <-
            tibble::tibble(cell = row.names(SummarizedExperiment::colData(cds)),
                           cell_group = SummarizedExperiment::colData(cds)[, lvl],
                           partition = monocle3::partitions(cds))
          agg_mat[[chunk_name_lvl]] <-
            monocle3::aggregate_gene_expression(
              cds[genes[[chunk_name_lvl]], ],
              cell_group_df = cell_group_df[[chunk_name_lvl]][, c("cell", "cell_group")])
          knit_lvl_module_heatmap <- c(
            '',
            paste0('```{r ', chunk_name_lvl, '_gene_heatmap, class.source = "fold-hide",  warning = F, message = F, fig.dim = c(10, max(length(genes[[chunk_name_lvl]]) / 6, 2))}'),
            paste0('p <- pheatmap::pheatmap(agg_mat[["', chunk_name_lvl, '"]], scale = "row", clustering_method = "ward.D2", fontsize = 6', ifelse(n_ct_markers == 1, ", cluster_rows = F", ""), ')'),
            'p',
            '```',
            ''
            )
          } else {
            knit_lvl_module_heatmap <- paste0(
              "Only one ", ifelse(n_ct_markers == 1, "gene", lvl), " so cannot produce a heatmap!\n")
          }
        
        dev_off_if()
        knitted_lvl_module_heatmap <- knitr::knit_child(text = knit_lvl_module_heatmap, envir = environment(), quiet = TRUE)
        dev_off_if()
        to_knit <- c(to_knit, knitted_lvl_module_heatmap)
      
      }

      if(n_ct_markers < 50) {
        knit_module_dimplots <- c(
          '',
          paste0('```{r ', chunk_name_ct, ', echo = F, warning = F, message = F, fig.dim = get_fig_dims((n_ct_markers + 2), n_cols = 4, height_to_width_ratio = 1.2)}'),
          'p <- plot_markers_on_umap(cds, ml = ct_markers, final_umap)',
          'p',
          '```',
          ''
          )
      } else {
        knit_module_dimplots <- paste(n_ct_markers, "markers in this set - too many to print!\n")
      }

      dev_off_if()
      knitted_module_dimplots <- knitr::knit_child(text = knit_module_dimplots, envir = environment(), quiet = TRUE)
      dev_off_if()
      to_knit <- c(to_knit, knitted_module_dimplots)

    }
  }
}
dev_off_if()
cat(unlist(to_knit), sep = '\n')
```

## Final cluster annotations

```{r summarise_annots, echo = F}
cell_groupings <-
  dplyr::as_tibble(SummarizedExperiment::colData(cds)) %>%
  tidyr::pivot_longer(c("cluster", "partition"), names_to = "cell_grouping", values_to = "cell_group") 

# lesion_types
cell_groupings %>%
  dplyr::group_by(cell_grouping, cell_group, lesion_type) %>%
  dplyr::count() %>% 
  dplyr::group_by(cell_grouping, cell_group) %>%
  dplyr::mutate(prop = n / sum(n)) %>%
  tidyr::pivot_wider(names_from = lesion_type, values_from = prop, id_cols = dplyr::starts_with("cell_group")) %>%
  dplyr::left_join(
    # singler_annots
    cell_groupings %>%
      tidyr::pivot_longer(dplyr::starts_with("singler_annot_")) %>%
      dplyr::group_by(cell_grouping, cell_group, name, value) %>%
      dplyr::count() %>% 
      dplyr::group_by(cell_grouping, cell_group, name) %>%
      dplyr::mutate(prop = n / sum(n) * 100,
                    label = paste0(value, " (", round(prop, ifelse(prop < 1, 1, 0)), "%)")) %>% 
      dplyr::filter(prop > 10) %>%
      dplyr::arrange(-prop) %>%
      dplyr::summarise(value = paste(label, collapse = ", ")) %>%
      tidyr::pivot_wider(),
    by = c("cell_grouping", "cell_group")
  ) %>%
  dplyr::left_join(
    # top_cds_markers
    top_cds_markers %>%
      dplyr::bind_rows(.id = "cell_grouping") %>%
      dplyr::group_by(cell_grouping, cell_group) %>% 
      dplyr::summarise(top_markers = paste(gene_id, collapse = ", ")),
    by = c("cell_grouping", "cell_group")
  ) %>%
  knitr::kable(digits = 3)
```

`r if (is.null(final_annotations)) { "Final celltype annotations of clusters have not been given. Please run the package again and pass celltype labels to the final_annotations argument to proceed with downstream analysis." }`

```{r exit_if_no_cts, include = is.null(final_annotations), eval = is.null(final_annotations)}
# truncate document if no final celltype annotations have been provided
knitr::knit_exit()
```

```{r final_annotations, echo = F}
# get final cluster annotations
final_annotations_df <-
  dplyr::left_join(
    tibble::as_tibble(SummarizedExperiment::colData(cds)),
    tibble::enframe(final_annotations,
                    name = final_annotations_lvl,
                    value = "final_annotation"),
    by = final_annotations_lvl
  )
# encode in the colData
SummarizedExperiment::colData(cds)$final_annotation <-
  final_annotations_df$final_annotation
```

```{r fca_kable, echo = F}
final_annotations_df %>%
  dplyr::select(dplyr::all_of(c(final_annotations_lvl, "final_annotation"))) %>%
  dplyr::group_by(dplyr::across(everything())) %>%
  dplyr::count() %>%
  knitr::kable()
```

```{r final_annotations_dimplot, class.source = 'fold-hide', fig.dim = c(10, 4.5), fig.cap = paste("Plot of Monocle3 UMAP, coloured by cluster and by final", final_annotations_lvl, "annotation")}
p <- 
  final_umap[[final_annotations_lvl]] + 
  dittoSeq::dittoDimPlot(cds, "final_annotation")
p
```

## Single cell trajectory analysis

# Copy number analysis

## Run `inferCNV`

`r if ("endothelial" %ni% SummarizedExperiment::colData(cds)$final_annotation) { "inferCNV requires an endothelial cluster as a baseline for CNV analysis, but the final celltype annotations (final_annotations argument) do not include an 'endothelial' cluster. Please run the package again with an 'endothelial' group specified in order to run inferCNV." }`

```{r exit_if_no_endothelial, include = "endothelial" %ni% SummarizedExperiment::colData(cds)$final_annotation, eval = "endothelial" %ni% SummarizedExperiment::colData(cds)$final_annotation}
# truncate document if no endothelial celltype annotations have been provided
knitr::knit_exit()
```

From [**github.com/broadinstitute/inferCNV/wiki**](https://github.com/broadinstitute/inferCNV/wiki)

>  ***InferCNV: Inferring copy number alterations from tumor single cell RNA-Seq data***
>
> *InferCNV is used to explore tumor single cell RNA-Seq data to identify evidence for somatic large-scale chromosomal copy number alterations, such as gains or deletions of entire chromosomes or large segments of chromosomes. This is done by exploring expression intensity of genes across positions of tumor genome in comparison to a set of reference 'normal' cells. A heatmap is generated illustrating the relative expression intensities across each chromosome, and it often becomes readily apparent as to which regions of the tumor genome are over-abundant or less-abundant as compared to that of normal cells.*

We annotate endothelial cells as matched normal and use this to infer copy number variants in the tumour population. Because 3p loss is the canonical founding event for ccRCC, we expect that the tumour cells will be those with 3p loss. Unlike CNVs called from bulk genotyping data, `inferCNV` can also reveal subclonal events in the tumour that only occur in some cell lineages, but not others. 

```{r run_infercnv, eval = F}
# create infercnv output directory
dir.create(out$infercnv, showWarnings = F)

# write annotations_file for infercnv
infercnv_annotations_file <- paste0(out$infercnv, "infercnv_annotations.tsv")
SummarizedExperiment::colData(cds)[, "final_annotation", drop = F] %>%
  write.table(infercnv_annotations_file, col.names = F, quote = F, sep = "\t")

# create infercnv object
infercnv_obj <- xfun::cache_rds({
  infercnv::CreateInfercnvObject(
    raw_counts_matrix = cds@assays@data$counts,
    annotations_file = infercnv_annotations_file,
    gene_order_file = "data/gencode/gencode.v43.basic.annotation_clean.bed",
    ref_group_names = c("endothelial")
  )
}, file = "infercnv_obj.rds", rerun = rerun)

# perform infercnv operations to reveal cnv signal
infercnv_obj <- xfun::cache_rds({
  infercnv::run(
    infercnv_obj,
    cutoff = 1,
    out_dir = out$infercnv,
    cluster_by_groups = T,
    denoise = T,
    HMM = T,
    resume_mode = rerun
  )
}, file = "infercnv_obj_processed.rds", rerun = rerun)
```

## Run `SCEVAN`

From [**github.com/AntonioDeFalco/SCEVAN**](https://github.com/AntonioDeFalco/SCEVAN)

>  ***Single CEll Variational Aneuploidy aNalysis (SCEVAN)***
>
>  *SCEVAN is an R package that starting from the raw count matrix of scRNA data automatically classifies the cells present in the biopsy by segregating non-malignant cells of tumor microenviroment from the malignant cells and also characterizes the clonal structure of these malignant cells. It identfies cell subpopulations with different copy number architecture and reports the specific and shared alterations of each subpopulation. The aim of the tool is to automate the entire analysis by allowing it to be performed in a very simple and completely unsupervised way.*

```{r scevan_dir, eval = F, include = F}
dir.create(out$scevan, showWarnings = F)
```

`SCEVAN` output will be saved to `r out$scevan`.

```{r run_scevan, message = F, warning = F, eval = F}
# split counts by sample
seu_counts_by_sample <- Seurat::SplitObject(seu, split.by = integration_col) %>%
  purrr::map(~ .x@assays$RNA@data)

# run SCEVAN
results <- SCEVAN::multiSampleComparisonClonalCN(seu_counts_by_sample)

# move output to SCEVAN dir
system(paste("mv output/*", out$scevan, "; rm -Rf output"))
```

