---
title: "VHL snRNAseq report"
output: html_document
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
---

``` {r setup, include = F}
# load vhl package
library(devtools)
load_all()

# gridExtra and clustree must be loaded in the environment (due to package-specific bugs)
library(clustree)
library(gridExtra)

# set wd
knitr::opts_chunk$set(root.dir = here::here(),
                      fig.align = "centre")

# get arguments and add to the global environment
args <- dget(here::here("out/221202_A01366_0326_AHHTTWDMXY/hg38/SHE5052A9_S101/all-well/DGE_filtered/unintegrated/args_for_generate_qc_report.R"))
args$parse_dir <- "/Volumes/TracerX/working/VHL_GERMLINE/tidda/parse_pipeline/"
list2env(args, globalenv())

# set ggplot theme
ggplot2::theme_set(ggplot2::theme_bw())
ditto_colours <- list(ggplot2::scale_fill_manual(values = dittoSeq::dittoColors()),
                      ggplot2::scale_colour_manual(values = dittoSeq::dittoColors()))

# define output directory
out <- {
    # if out_dir not given, use same output structure as in the parse analysis/ directory
    if (is.null(out_dir)) "out/" %>%
      paste(experiment, genome, sublibrary, parse_analysis_subdir, sep = "/") %>%
      { if (do_integration) paste0(., "/integrated/") else paste0(., "/unintegrated/")} %>%
      { if (do_timestamp) paste0(., format(Sys.time(), "%Y%m%d_%H%M%S"), "/") else . }
    # if out_dir is given, use out_dir
    else out_dir
    # clean path (// -> /)
  } %>% clean_path() %>% {
    # pre-set file names (TODO: define these once all outputs are finalised)
    purrr::map(list(base = ""), function(x) paste0(., x))
  }

# set sample groupings to check at the clustering stage
groupings <- c("sample", "percent_mito", "percent_ribo", "percent_globin",
                 "date_prep", "nih_pid", "rin", "lesion_type", "tumour_size", "fuhrman_grade") %>%
    # if genome is human, do cell cycle scoring (doesn't work with other genomes)
    { if (grepl("hg38", genome)) c(., "Phase") else . } %>%
    # if checking for doublets, add to the groupings
    { if (remove_doublets) c(., "doublet") else . }
```

All outputs will be saved to `r out$base`.

## Load data and filter genes

Load Parse Biosciences split-pipe pipeline output as a Seurat object with no cut-offs, remove any missing samples, add sample metadata, add summary statistics, and optionally subset samples. Then filter nuclei per gene. 

Gene-level filtering is also performed at this point, based on the `min_nuclei_per_gene` argument. Genes that are present in very few nuclei of the dataset (e.g., <3) are uninformative and unlikely to help in differentiating between groups of nuclei. In general, most genes removed by this filtering step will be those not detected in any nuclei, which will help to trim the size of the object. 

The minimum number of nuclei per gene is set to **`r min_nuclei_per_gene`**.

``` {r load_data, warning = F}
# seu <- load_parse_to_seurat(
#     parse_dir,
#     experiment,
#     genome,
#     sublibrary,
#     parse_analysis_subdir,
#     min_nFeature_RNA = 0,
#     min_nuclei_per_gene = min_nuclei_per_gene,
#     sample_subset,
#     remove_na_samples = T,
#     do_add_sample_metadata = T,
#     do_add_summary_stats = T,
#     groupings
#   ) 
# # save seu 
# saveRDS(seu, file = here::here(out$base, "seu.rds"))
seu <- readRDS(here::here(out$base, "seu.rds"))
seu <- seu[sample(nrow(seu), nrow(seu)*0.5),sample(ncol(seu), ncol(seu)*0.1)]
``` 

## Sample-level overview

Nuclei per sample

```{r nuclei_per_sample_plot, echo = F, message = F, warning = F}
p <-
  dplyr::tibble(sample_id = names(table(seu$sample)),
                n_nuclei = table(seu$sample)) %>%
  ggplot2::ggplot(ggplot2::aes(x = sample_id, y = n_nuclei)) +
  ggplot2::geom_col() +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
p
```

#### Plot of summary statistics by sample

```{r summary_statistics_plot, echo = F, message = F, warning = F, fig.height = 15}
p <-
  seu@misc$summary_stats %>%
  ggplot2::ggplot(ggplot2::aes(x = sample, y = value)) +
  ggplot2::geom_col() +
  ggplot2::facet_grid(statistic ~ ., scales = "free") +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90))
p
```

## Filter nuclei

Nucleus-level filtering is performed, applying cut-offs to `nCount_RNA`, `nFeature_RNA`, `percent_mito`, and `doublet` values of each nucleus.

* Unusually high transcript / gene counts indicate multiplets.
* Unusually low transcript / gene counts indicate barcoding of nuclei with damaged membranes, which are likely low-quality and uninformative.
* A high percentage of mitochondrial genes indicates death, loss of cytoplasmic RNA, or increased apoptosis. Differences in the application of this filter between scRNA-seq and snRNA-seq are not well covered in literature. Intuitively, snRNA-seq data should be treated with a more stringent cut-off, as it should only include nuclear RNA. However, the renal cortex has an exceptionally high level of mitochondrial activity, so this cut-off has been relaxed somewhat for the VHL dataset. 
* Nuclei with a high nFeature_RNA:nCount_RNA ratio could be from dying cells.

### Annotate doublets

Putative doublets are identified using the `scDblFinder` package. This package creates artificial doublets by grouping together random pairs of nuclei within each sample to create pseudo-doublets, and then identifying nuclei that cluster near to these pseudo-doublets during dimensionality reduction. This co-clustering indicates that they carry a doublet signature. 

The `remove_doublets` argument is set to **`r remove_doublets`**.
`r if (remove_doublets) {"Doublets will be identified and removed." }`
`r if (!remove_doublets) {"A dummy column will be introduced, treating all nuclei as though they are singlets."}`

```{r identify_doublets, eval = remove_doublets, include = remove_doublets}
seu <- annotate_doublets(seu)
```

```{r ignore_doublets, eval = remove_doublets == F, include = remove_doublets == F}
seu$doublet <- 0
```

#### `r if (remove_doublets) {"Plot of detected doublets in each sample (using scDblFinder)"}`

```{r detected_doublets_plot, eval = remove_doublets, echo = F}
p <-
  seu@meta.data[,c("sample", "doublet")] %>% 
    dplyr::group_by(sample) %>%
    dplyr::mutate(n_doublets = sum(doublet),
                  is_doublet = doublet == 1) %>%
    tidyr::pivot_longer(names(seu@misc$filters)) %>%
    ggplot2::ggplot(ggplot2::aes(y = value, x = sample, colour = is_doublet)) +
    ggplot2::geom_jitter(data = . %>% dplyr::filter(!is_doublet), height = 0) +
    ggplot2::geom_jitter(data = . %>% dplyr::filter(is_doublet), height = 0) +
    ggplot2::facet_wrap(~ name, scales = "free") +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90)) +
    ditto_colours
p
```

### Annotate transcript types

Proportions of transcript types of interest (mitochondrial, ribosomal, globin) are annotated. Mitochondrial genes are particularly of interest for filtering, but it is good practice to inspect the others as well.

* `percent_mito` - A high percentage of mitochondrial genes indicates death, loss of cytoplasmic RNA, or increased apoptosis.
* `percent_ribo` - mRNA that code for ribosomal proteins. They do not point to specific issues, but it can be good to have a look at their relative abundance. They can have biological relevance.
* `percent_globin` - Globin genes are very abundant in erythrocytes. Depending on your application, you can expect ‘contamination’ of erythrocytes and select against it.

```{r annotate_transcript_types}
seu <- annotate_proportions_of_transcript_types(seu)
```

### Define nucleus-level filters

The `do_filtering` argument is set to **`r do_filtering`**.
`r if (do_filtering) {"Filters will be applied." }`
`r if (!do_filtering) {"Dummy filters will be set (min = -Inf, max = Inf) and all nuclei will be retained." }`

```{r get_filters}
seu <- get_filters(
  seu,
  do_filtering,
  remove_doublets,
  min_nCount_RNA,
  max_nCount_RNA,
  min_nFeature_RNA,
  max_nFeature_RNA,
  max_percent_mito
)
```

`r paste(paste("*", names(unlist(seu@misc$filters))) %>% gsub("\\.", " ", .), paste0("**", unlist(seu@misc$filters), "**"), collapse = "  \n", sep = " = ")`

#### Plot of filters vs feature distribution

```{r filters_vs_distribution_vln, echo = F, message = F, warning = F, fig.height = 10, fig.width = 10}
p <- 
    seu@misc$nucleus_filtering %>%
    tidyr::pivot_longer(names(seu@misc$filters)) %>%
    dplyr::left_join(seu@misc$filters %>%
                       purrr::map(~dplyr::as_tibble(.)) %>%
                       dplyr::bind_rows(.id = "name"),
                     by = "name") %>%
    dplyr::group_by(fail_criteria) %>%
    ggplot2::ggplot(ggplot2::aes(x = sample, y = value)) +
    ggplot2::geom_jitter(ggplot2::aes(colour = pass),
                         height = 0, alpha = 0.5, size = 0.6) +
    ggplot2::geom_violin(ggplot2::aes(fill = sample), alpha = 0.8,
                         draw_quantiles = 0.5) +
    ggplot2::geom_hline(ggplot2::aes(yintercept = min), colour = "red") +
    ggplot2::geom_hline(ggplot2::aes(yintercept = max), colour = "red") +
    ggplot2::facet_wrap(~ name, scales = "free") +
    ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 90)) +
    ditto_colours +
    ggplot2::scale_colour_manual(values = c("darkgrey", "black"))
p
```

#### Plot of the proportions of filtered nuclei and their fail criteria for each sample

```{r fail_criteria_proportions, echo = F}
p <- 
     seu@misc$nucleus_filtering %>%
    dplyr::group_by(sample) %>%
    dplyr::count(fail_criteria) %>%
    ggplot2::ggplot(ggplot2::aes(x = sample, y = n, fill = fail_criteria)) +
    ggplot2::geom_col() +
    ditto_colours
p
```

#### Plot of filters against distribution of nuclei

```{r nucleus_scatter_with_filters, echo = F, fig.width = 10}
p <- 
    plot_nucleus_scatter_with_filters(seu, "nCount_RNA", "percent_mito", log_y = T) +
    ggplot2::theme(legend.position = "none") +
    plot_nucleus_scatter_with_filters(seu, "nCount_RNA", "nFeature_RNA")
p
```

### `r if (do_filtering) {"Apply nucleus-level filters"}`

```{r filter_nuclei, eval = do_filtering, include = do_filtering}
seu <- subset(seu, cells = unique(dplyr::filter(seu@misc$nucleus_filtering, pass)$nucleus))

# save seu_filtered
saveRDS(seu, here::here(out$base, "seu_filtered.rds"))
```

```{r calc_n_retained, include = F} 
n_retained <- nrow(dplyr::filter(seu@misc$nucleus_filtering, pass))
```

`r paste0(round((n_retained / ncol(seu)) * 100, 1), "% (", n_retained, "/", ncol(seu), ") of nuclei retained.")`

## Highest variable genes

Find the most highly variable genes (HVGs) across samples.

```{r hvg, message = F, warning = F}
seu <- Seurat::FindVariableFeatures(seu)
```

#### Plot of HVGs

```{r hvg_scatter, echo = F, warning = F, message = F}
p <- 
  Seurat::LabelPoints(
    plot = Seurat::VariableFeaturePlot(seu, raster = F),
    points = head(Seurat::VariableFeatures(seu), 10),
    repel = T
  ) +
    ggplot2::theme(legend.position = "top")
p
```

#### Heatmap of top 20 HVGs

```{r hvg_heatmap, echo = F}
p <- 
  dittoSeq::dittoHeatmap(
    seu,
    genes = head(Seurat::VariableFeatures(seu), 20),
    annot.by = "sample",
    scaled.to.max = T
  )
p
```

## Integration (optional)

## Normalisation and scaling

Seurat::SCTransform() is a function that performs normalisation and scaling of the data. 

Variables to regress out of the SCTransform residuals  (argument `vars_to_regress`) are **`r paste(vars_to_regress, collapse = "** and **")`**. These variables are prevented from contributing much to the PCA during dimensionality reduction, and thus confounding the analysis due to irrelevant variation.

```{r sctransform, results = 'hide', warning = F}
seu <- Seurat::SCTransform(seu, vars.to.regress = vars_to_regress)

# save seu_transformed
saveRDS(seu, file = here::here(out$base, "seu_transformed.rds"))
```

## Annotate cell cycle phases

Nuclei are assigned a score representing the likelihood that they are in each phase of the cell cycle. This is based on the expression levels of genes associated with each phase. The highest probability phase of each nucleus is stored in a new "Phase" column of the metadata.

```{r annotate_cell_cycle_phases}
seu <- Seurat::CellCycleScoring(
  seu,
  s.features = Seurat::cc.genes$s.genes,
  g2m.features = Seurat::cc.genes$g2m.genes
)
```

## Dimensionality reduction

Dimensionality reduction is performed to isolated the strongest signals and to remove background noise. 

### Linear dimensionality reduction (PCA)

```{r run_pca}
seu <- Seurat::RunPCA(seu)
```

#### Plot of PC1 vs PC2, coloured by sample

```{r pc1_vs_pc2, echo = F}
p <- 
  dittoSeq::dittoDimPlot(seu, "sample", reduction.use = "pca", raster = F)
p
```

#### Plot of cells and genes sorted by their PC scores for PC1 and PC2

```{r pca_dim, echo = F}
p <- 
  Seurat::DimHeatmap(
    seu,
    dims = 1:2,
    cells = 500,
    balanced = TRUE,
    raster = F,
    fast = F
  )
p
```

#### Plot of top genes associated with PC1 and PC2

```{r top_genes_pc1_pc2, echo = F}
p <- 
  Seurat::VizDimLoadings(seu, dims = 1:2, reduction = "pca")
p
```

### Dimensionality of the data

The dimensionality of the dataset to use for downstream analysis must be decided. This is the number of principal components believed to capture the majority of true biological signal in the dataset. Using too many PCs usually does not affect the result too much, while including too few PCs can be detrimental, as meaningful biological variation may be lost. Therefore, it is better to be overgenerous when defining the dimensionality of the data than to underestimate it.

The dimensionality can be decided by consulting the elbow plot (see below) and manually picking a value (set by argument `n_dims`) or it can be calculated using the `intrinsicDimensionality` package. 

#### `r if (!is.null(n_dims)) {"Manually"}`

`r if (!is.null(n_dims)) {paste0("Dimensionality of the data is **", n_dims, "** (set by argument n_dims).")}`

```{r usr_n_dims, include = !is.null(n_dims), eval = !is.null(n_dims)}
final_n_dims <- n_dims
```

#### intrinsicDimensionality

`r if (is.null(n_dims)) {"No value was provided for n_dims, so dimensionality will be calculated using the intrinsicDimensions package."}`

The dimensionality of the dataset can also be estimated using the intrinsicDimension package. This bypasses the manual approach of reading the elbow plot, but can sometimes be a bit too conservative. Therefore, if `n_dims` is not defined by the user, the dimensionality is set as double the intrinsicDimension estimate. 

```{r iD_n_dims}
n_dims_iD <- intrinsicDimension::maxLikGlobalDimEst(
    seu@reductions$pca@cell.embeddings,
    k = 10
  )$dim.est %>% round(0)
generous_n_dims <- round(2 * n_dims_iD, 0)
```

```{r iD_n_dims_set, include = is.null(n_dims), eval = is.null(n_dims)}
final_n_dims <- generous_n_dims
```

#### Elbow plot

```{r elbow_plot, echo = F}
p <-
  Seurat::ElbowPlot(seu, ndims = max(50, final_n_dims)) &
  ggplot2::geom_vline(
    ggplot2::aes(xintercept = final_n_dims, 
                 colour = ifelse(is.null(n_dims), "chosen n_dims", "user-provided n_dims")),
                 linewidth = 1) &
  ggplot2::geom_vline(ggplot2::aes(xintercept = n_dims_iD, colour = "intrisicDimensions"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::geom_vline(ggplot2::aes(xintercept = generous_n_dims, colour = "generous (iD x 2)"),
                      linewidth = 1, linetype = "dashed") &
  ggplot2::scale_colour_manual(
    name = "n_dims cut-off",
    values = c(`chosen n_dims` = dittoSeq::dittoColors()[[1]],
               `user-provided n_dims` = dittoSeq::dittoColors()[[1]],
               intrisicDimensions = dittoSeq::dittoColors()[[2]],
               `generous (iD x 2)` = dittoSeq::dittoColors()[[3]])) &
  ggplot2::theme(legend.position = c(0.7, 0.9),
                 legend.background = ggplot2::element_rect(fill = "white"))
p
```

Dimensionality set to **`r final_n_dims`**.

### Non-linear dimensionality reduction (UMAP, tSNE)

```{r run_nonlin_dim_red, warning = F, message = F, echo = F}
seu <- Seurat::RunTSNE(seu)
seu <- Seurat::RunUMAP(seu, dims = 1:final_n_dims)
```

#### Plot of UMAP and tSNE, coloured by sample

```{r nonlin_dim_red_plot, echo = F, fig.width = 10}
p <-
  dittoSeq::dittoDimPlot(seu, "sample", reduction.use = "umap", raster = F,
                         legend.show = F) +
  dittoSeq::dittoDimPlot(seu, "sample", reduction.use = "tsne", raster = F) 
p
```

#### Plot of all reductions, coloured by groupings

A plot of all available groupings of the data, projected onto the three dimensionality reductions (PCA, UMAP, and tSNE).

```{r groupings_vs_reductions, echo = F, fig.dim = c(10, 30)}
# amend groupings
avail_groupings <- groupings[groupings %in% colnames(seu@meta.data)]
# plot all groupings vs all reductions
groupings_vs_reductions <- list()
purrr::walk(avail_groupings, function(grouping) {
  purrr::walk(Seurat::Reductions(seu), function(redu) {
    title <- paste0(redu, "_vs_", grouping)
    p <- dittoSeq::dittoDimPlot(
      seu,
      grouping,
      reduction.use = redu,
      size = 0.5,
      raster = F,
      show.axes.numbers = F,
      show.grid.lines = F,
      main = gsub("_", " ", title)
    )
    groupings_vs_reductions[[paste0(grouping, "_legend")]] <<-
      lemon::g_legend(p)
    groupings_vs_reductions[[title]] <<-
      p + ggplot2::theme(legend.position = "none")
  })
})
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = groupings_vs_reductions,
    nrow = length(groupings),
    ncol = length(Seurat::Reductions(seu)),
    layout_matrix = matrix(
      1:length(groupings_vs_reductions),
      length(groupings),
      length(Seurat::Reductions(seu)) + 1,
      TRUE
    ),
    top = NULL
  )
p
```

## Clustering

From [**Clarke et al., 2021**](https://www.nature.com/articles/s41596-021-00534-0)

>  ***Annotating cell states and gradients***
>  *When analyzing and characterizing novel cell types, it is important to determine whether they represent a stable cell type or contain multiple cell states. The definitions of cell type and state are not yet standardized, but a stable cell type may be expected to have homogeneous gene expression across a cluster and be compact in a 2D projection plot, whereas cell gradients appear as a spread-out string of cells and cell states (e.g., cell cycle state). Expression gradients indicate continuous differences that are present in the cell population, which could represent states like the cell cycle, immune activation63, spatial patterning64 or transient developmental stages. Care must be taken to distinguish biologically meaningful cell states and experimental batch effects, which can manifest in a similar way.*

We perform unsupervised transcriptome similarity-based clustering to identify groups of nuclei with relatively homogeneous transcript profiles (united by a shared celltype / state). Clustering is performed at different resolutions to explore how groupings change across the parameter space. The aim is to find a resolution at which the clusters appear to best reflect true biological subpopulations of the dataset. 

This process is based on the assumption that true discrete clusters of nuclei do exist within the dataset. The preceding nucleus filtering, feature selection, and dimensionality reduction steps were taken to distill only the highest quality features that reflect the underlying structure of the population and to remove noise that distracts from this structure.  

As with the final dimensionality parameter, there is no deterministic way to set the final clustering resolution and no definitive best value. Instead, one must qualitatively assess clustering outputs for the given dataset and pick a 'good' resolution. Typically, a 'good' final resolution is taken as one that groups nuclei into celltypes. However, looking at multiple clustering resolutions of the same dataset can provide multiple true and valuable conclusions about the dataset at multiple levels of functional subspecialisation of cells. 

Setting a **low clustering resolution** will produce fewer clusters, reflect the broadest subdivisions between groups of nuclei (e.g. different tissues / differentiation lineages), and is more robust to noise, but can miss important local structure within the dataset. 

**Higher clustering resolutions** will result in more, increasingly granular clusters and can reveal celltype-level groups. In can also reveal new / rare celltypes that are hidden at lower resolutions. Setting the clustering resolution too high, however, can produce meaningless groups and lead to overfitting. 

### Find neighbours

The first step is to compute the `k.param` nearest neighbours for a given dataset. This step constructs a shared nearest neighbours (SNN) graph from euclidean distances between nuclei in PCA space, and then computes edge weights between each pair of nuclei based on their Jaccard similarity (the shared overlap of their local neighborhoods).

```{r find_neighbours}
seu <- Seurat::FindNeighbors(seu, dims = 1:final_n_dims)
```

### Find clusters at different clustering resolutions

Then, groups of nuclei are iteratively grouped together. Clusters are identified by a SNN modularity optimisation-based clustering algorithm. This procedure is repeated for all clustering resolutions to be tested (set by the `clustering_resolutions` argument). 

The clustering resolutions to be tested are **`r paste(clustering_resolutions, sep = ", ")`**.

```{r find_clusters}
seu <- Seurat::FindClusters(seu, resolution = clustering_resolutions, verbose = F)
```

### Evaluate all clustering resolution

#### Plot of all reductions, coloured by clusters

A final clustering resolution can be decided by looking for sensible groupings of nuclei projected onto the dimensionality reduction plots. 

```{r resolutions_vs_reductions, echo = F, fig.dim = c(10, 30)}
# plot all clustering resolutions vs all reductions
resolutions_vs_reductions <- list()
purrr::walk(clustering_resolutions, function(res) {
  purrr::walk(Seurat::Reductions(seu), function(redu) {
      title <- paste0(redu, "_by_cluster_res_", res)
      resolutions_vs_reductions [[title]] <<-
        dittoSeq::dittoDimPlot(
          seu,
          paste0(Seurat::DefaultAssay(seu), "_snn_res.", res),
          reduction.use = redu,
          size = 0.5,
          raster = F,
          legend.show = F,
          show.axes.numbers = F,
          show.grid.lines = F,
          main = gsub("_", " ", title)
        )
    })
})
# create grob layout
p <-
  gridExtra::marrangeGrob(
    grobs = resolutions_vs_reductions ,
    nrow = length(clustering_resolutions),
    ncol = length(Seurat::Reductions(seu)),
    layout_matrix = matrix(1:length(resolutions_vs_reductions ),
                           length(clustering_resolutions),
                           length(Seurat::Reductions(seu)),
                           TRUE),
    top = NULL
  )
p
```

#### Plot of clustering tree

Alternatively, the `clustree` package provides a more intuitive way to visualise clustering behaviour at different resolutions and to devide on a final clustering resolution. It constructs clustering trees that show how samples move and split up as the number of clusters increases. A 'solid' clustering resolution is taken as one in a part of the tree where clusters remain relatively stable and constant for a few resolution. This indicates that the groups are robust and strongly supported by the data, rather than volatile and noisy. 

```{r clustering_tree, echo = F}
snn_res_prefixes <- paste0(Seurat::DefaultAssay(seu), "_snn_res.")
p <- 
  clustree::clustree(seu@meta.data[, grep(snn_res_prefixes, colnames(seu@meta.data))],
                       prefix = snn_res_prefixes)
p
```

### Choose a final clustering resolution

`r if (is.null(final_clustering_resolution)) { "A final clustering resolution has not been given. Please run the package again and pass a resolution to the final_clustering_resolution argument to proceed with downstream analysis." }`

```{r exit_if_no_res, include = is.null(final_clustering_resolution), eval = is.null(final_clustering_resolution)}
# truncate document if no final clustering resolution has been provided
knitr::knit_exit()
```

The final clustering resolution has been set to **`r final_clustering_resolution`**.

```{r set_res}
seu$cluster <- seu@meta.data[, paste0(snn_res_prefixes, final_clustering_resolution)]

# save seu_clustered
saveRDS(seu, here::here(out$base, "seu_clustered.rds"))
```

#### Plots of clusters per sample and samples per cluster

```{r clusters_per_sample, echo = F}
p <-
  dittoSeq::dittoBarPlot(seu,
                         var = "cluster",
                         scale = "count",
                         group.by = "sample",
                         main = "",
                         legend.title = "cluster") +
  ggplot2::theme(legend.position = "left") +
  dittoSeq::dittoBarPlot(seu,
                         var = "sample",
                         scale = "count",
                         group.by = "cluster",
                         main = "",
                         legend.title = "sample") +
  patchwork::plot_layout(
    ncol = 2,
    widths = c(
      seu$sample %>% unique() %>% length(),
      seu$cluster %>% unique() %>% length()
    )
  )
p
```

## Celltype annotation

The conventional approach to celltype annotation for sc/snRNAseq datasets is to inspect known marker genes from each of the celltypes that are expected and likely to be found at the sample site. Known relationships between marker genes and celltypes of interest can be obtained from databases or manually curated from literature. Then, the expression profiles of all markers from all celltypes across all clusters is programmatically or visually inspected and clusters are then labelled according to their marker profile. 

### Automated annotation using database markers

The package `SingleR` returns "the best annotation for each cell in a test dataset, given a labelled reference dataset in the same feature space". Using the human primary cell atlas from `celldex`, we can find the nearest reference celltype to each nucleus in the dataset. This approach is good because it is unbiased and does not require manual assignment, but it is unclear how well snRNAseq output will map onto a scRNAseq atlas. Additionally, the reference dataset from `celldex` is more rigid, cannot be customised to the use case, and does not contain transformed celltypes. 
```{r singler_annots, message = F, warning = F}
human_primary_ref <- celldex::HumanPrimaryCellAtlasData()
seu_singler <- SingleR::SingleR(
  test = Seurat::GetAssayData(seu, slot = "data"),
  ref = human_primary_ref,
  labels = human_primary_ref$label.main
)
```

#### Heatmap of celltype annotation scores from SingleR

```{r singler_annots_heatmap, echo = F, fig.width = 10}
p <-
  SingleR::plotScoreHeatmap(seu_singler,
                            annotation_col = data.frame(
                              patient = seu$nih_pid,
                              lesion_type = seu$lesion_type
                            ))
p
```

#### Delta distribution of celltype annotations from SingleR

```{r singler_annots_delta, echo = F, warnings = F, message = F}
p <-
  SingleR::plotDeltaDistribution(seu_singler)
p
```

Some annotations will contain very few nuclei. These are usually not of interest and clutter up plotting, so we remove annotations assigned to < 10 nuclei.

```{r assign_singler_annots}
seu$singler_annot <- seu_singler %>%
      dplyr::as_tibble() %>%
      dplyr::group_by(labels) %>%
      dplyr::transmute(singler_annot = replace(labels, dplyr::n() < 10, "none")) %>%
      dplyr::pull(singler_annot)
```

#### Plot of UMAP clusters, coloured by SingleR annotation and labelled by majority SingleR annotation per cluster

```{r umap_vs_singler_annots, echo = F, fig.width = 10, fig.height = 3}
# add celltype annotation labels for plotting
seu$singler_annot_label <- seu@meta.data %>%
  dplyr::group_by(cluster, singler_annot) %>%
  dplyr::count() %>%
  dplyr::group_by(cluster) %>%
  dplyr::mutate(total = sum(n),
                prop = round(n / sum(n) * 100, 0),
                label = paste0(singler_annot, " (", prop, "%)")) %>%
  dplyr::filter(prop == max(prop) & prop > 50 | max(prop) < 50 & rank(-prop) <= 2) %>%
  dplyr::summarise(label = paste0("cluster ", unique(cluster), " (n = ", unique(total), ")\n", paste(label, collapse = "\n"))) %>%
  {dplyr::left_join(seu@meta.data[, "cluster", drop = F], multiple = "all", ., by = "cluster")} %>%
  dplyr::pull(label)
# plot
p <-
  dittoSeq::dittoDimPlot(seu, "singler_annot", size = 0.7) +
  ggplot2::geom_label(
    data = seu@meta.data %>%
      dplyr::right_join(get_centroids(seu, "umap", cluster), by = "cluster") %>%
      dplyr::distinct(cluster, singler_annot_label, x, y),
    ggplot2::aes(x, y, label = singler_annot_label),
    size = 3,
    fill = 'white',
    color = 'black',
    alpha = 0.5,
    label.size = 0,
    show.legend = FALSE,
    fontface = "bold",
    vjust = "inward",
    hjust = "inward"
  ) +
  ggplot2::theme(legend.position = "left") +
  dittoSeq::dittoDimPlot(seu, "sample", size = 0.7) 
p
```

#### Plot of SingleR annotation composition of samples

```{r singler_annots_bar, echo = F}
p <-
  dittoSeq::dittoBarPlot(
  seu,
  var = "singler_annot",
  group.by = "sample",
  scale = "count",
  legend.show = F
  ) +
  dittoSeq::dittoBarPlot(seu,
                         var = "singler_annot",
                         group.by = "cluster",
                         scale = "count") +
  patchwork::plot_layout(
    ncol = 2,
    widths = c(
      seu$sample %>% dplyr::n_distinct(),
      seu$cluster %>% dplyr::n_distinct()
    )
  )
p
```

#### Alluvial plot of assignment paths of nuclei from samples to clusters to SingleR annotations

```{r singler_annots_alluvial, echo = F, fig.width = 10}
p <-
  seu@meta.data %>%
  dplyr::group_by(sample, cluster, singler_annot) %>%
  dplyr::count() %>%
  dplyr::ungroup() %>%
  ggforce::gather_set_data(1:3) %>%
  dplyr::mutate(x = dplyr::case_when(x == 1 ~ "sample",
                                     x == 2 ~ "cluster",
                                     x == 3 ~ "singler_annotation") %>%
                  factor(levels = c("sample", "cluster", "singler_annotation"))) %>%
  ggplot2::ggplot(ggplot2::aes(
                    x = x,
                    id = id,
                    split = y,
                    value = n
                  )) +
  ggforce::geom_parallel_sets(ggplot2::aes(fill = cluster),
                              axis.width = 0.15,
                              alpha = 0.75) +
  ggforce::geom_parallel_sets_axes(fill = "lightgrey",
                                   axis.width = 0.15) +
  ggforce::geom_parallel_sets_labels(angle = 0,
                                     nudge_x = c(
                                       rep(-0.3, dplyr::n_distinct(seu$sample)),
                                       rep(0, dplyr::n_distinct(seu$cluster)),
                                       rep(0.3, dplyr::n_distinct(seu$singler_annot))
                                     )) +
  ggplot2::theme_void() +
  ggplot2::theme(legend.position = "none",
                 axis.text.x = ggplot2::element_text(face = "bold", size = 15)) +
  ditto_colours
p
```

### Manual annotation using curated literature markers

Literature markers for celltypes of interest in VHL ccRCC tumours were gathered from previous sc/snRNAseq studies of sporadic ccRCC. 
